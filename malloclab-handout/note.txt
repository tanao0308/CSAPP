>>> CSAPP 虚拟内存 章节 读书笔记
    9.3: 页表
        操作系统为每个进程维护一个它的页表。
        程序的空间被描述为一个虚拟内存空间，大小是 0 到 （实际内存 + swap空间）
        程序的虚拟内存空间被划分为多个页，每一页大约 4KB ，且每一页有三种状态：
            未分配：指程序还没对这块内存空间进行使用，例如 pc 指针没有指向的指令地址，或者堆区上部到栈区下部这块空间。
                    总之该虚拟页里存的东西只要在将来可能被用到，就成为已分配。
            未缓存：指此页在外存（swap区域）而不在内存
            已缓存：指此页在内存。
        在创建进程时，操作系统不会将任何代码加载进内存，只会加载 .text 和 .data 两个值。所有的加载都通过缺页异常进行。
    9.7.2: linux 虚拟内存系统
        地址从低到高分别是 代码，已初始化数据，未初始化数据，堆，共享库内存映射区域，栈，内核虚拟内存
        其中内核虚拟内存分为 内核代码和全局数据结构，物理内存，与本进程相关的数据结构（页表等）
    9.9: 动态内存分配
        分配器：
            显示分配器：
                malloc free, new delete
            隐式分配器：
                garbage collector

>>> 找不到 asm 头文件
    https://askubuntu.com/questions/530248/asm-errno-h-no-such-file-or-directory

>>> 如何测试
    make && ./mdriver -f short1-bal.rep
    make && ./mdriver -t traces/
        trace：测试的编号或者标识，表示不同的测试用例。
        valid：表示测试是否有效，"yes" 表示测试是有效的，"no" 表示测试无效或失败。
        util：内存使用率，表示分配器实际使用的内存占所有已分配内存的百分比。例如，99% 表示分配器只浪费了 1% 的内存。
        ops：每个测试用例执行的操作次数，表示内存分配器进行的分配和释放操作的总数。
        secs：该测试用例的运行时间，单位为秒，表示测试的执行时长。
        Kops：每秒进行的千操作次数，即每秒执行的操作次数的千分之一，通常用来衡量分配器的吞吐量，单位是千操作（Kops）。

>>> 静态链接库 动态链接库
    区别是静态链接库会将二进制代码指令在一开始就加入程序的代码区和常量区（完全融入）
    而动态链接库只有当调用到库内要使用的函数时，才会将对应的指令加入堆区上部、栈区下部这个位置，不过运行此代码使用的堆栈还是和原程序共享的

>>> (void *)p 自增时的行为
    对于 void * 类型的指针，自增操作实际上没有定义，因为 void 是一个不带大小的类型，没有办法知道应该跳过多少字节来指向下一个元素。因此，void * 指针是无法直接进行加法或自增操作的。
    不过，在 C 语言标准中，有一种特例，void * 指针自增时，会被转换为指向 char 类型的指针（因为 char 的大小是 1 字节），然后再进行加法操作。具体来说：
        (void *)p++ 会首先把 p 转换成 char *，然后执行自增，增加的字节数为 1 字节。
    因此，(void *)p++ 会使指针增加 1 字节，尽管 void 类型没有定义大小，但编译器会将其当作 char 类型处理，增加 1 字节。